
Транспортный справочник.
========================

Введение.
---------

  Данный   проект   также    представляет    собой    некоторую    пародию    на
Яндекс.Транспорт,     до     крайности     упрощенный    бекэнд    транспортного
справочника,  который  позволяет  создавать  и  хранить  маршрутную транспортную
сеть  некоего  абстрактного  населённого  пункта,  а  также  получать  некоторые
сведения    об    этой   транспортной   сети   путём   совершения   определённых
информационных запросов к справочнику.

  Практическая  ценность  этой  программы,  конечно,  весьма  относительна.  Она
представляет  собой,  скорее,  теоретический  и  исследовательский  интерес. Но,
несмотря   на   это,   для  решения  некоторых  практических  задач  она  вполне
пригодна.

  Интерфейс  справочника  весьма   прост,  осуществляется  путём  обмена  с  ним
JSON-документами,  содержащими  как  запросы  к  нему,  так  и  возвращаемые  им
ответы.  Каждый  JSON-документ  может  содержать  в  себе  целую серию запросов,
в  этом  случае  возвращаемый  документ  также  будет содержать серию ответов на
все переданные запросы.

  С  точки  зрения   программы-фронтенда   справочник   представляет  собой  два
взаимосвязанных    объекта.    Во-первых,    это    основной    объект    класса
TransportCatalogue,  который  перед  работой  с  системой  нужно  предварительно
создать,  и  который  будет  существовать  на  протяжении всего сеанса работы со
справочником.

  Во-вторых,   это   вспомогательный    объект-посредник    класса   JSONReader,
который   служит   для   приёма   и   передачи   справочнику  JSON-документов  с
запросами   и  ответами.  Этот  объект  следует  создавать  заново  для  каждого
обмена   информацией   со  справочником,  включающего  в  себя  передачу  одного
JSON-документа  с  запросами  и  получение  одного  соответствующего документа с
ответами.

Описание программного интерфейса справочника.
---------------------------------------------

  Все  классы  справочника   объявлены   внутри   пространства  имён  transport.
Создание   главного  объекта  класса  TransportCatalogue  выполняется  следующим
образом:

    transport::TransportCatalogue trans_cat;

  Источником   документа-запроса   может   служить   любой   потоковый   объект,
приводимый   к   классу  istream.  Связь  такого  потока  с  созданным  объектом
справочника      выполняется     объектом-посредником     класса     JSONReader,
определённым       внутри       пространства       имён       transport::reader.
Вся   необходимая   информация  передаётся  его  конструктору.  Создание  такого
промежуточного объекта может выглядеть так:

    transport::reader::JSONReader jsr(i_stream, trans_cat);

где    i_stream   -   переменная   любого   потока,   приводимого   к   istream,
trans_cat        -        ранее        созданный       объект       справочника.
Поток   i_stream   при   выполнении   операций   считывания   из   него   должен
возвращать               тело               JSON-документа              запроса.
Считывание  и  перевод  текстового  JSON-документа  во  внутреннее представление
справочника   будет   выполнено   непосредственно  в  конструкторе,  после  чего
поток   i_stream  далее  не  нужен  и  может  быть  уничтожен  или  преобразован
вызывающей программой любым другим способом.

-------------------------------------------

  Все  запросы  делятся   на   три  категории:  запросы  построения  -  запросы,
содержащие  информацию,  служащую  для  построения  базы  данных  со  сведениями
об  устройстве  транспортной  маршрутной  системы,  запросы  получения - запросы
на   получение   определённой   информации   от   справочника,  конфигурационные
запросы   -   запросы,  передающие  справочнику  различные  уставки  и  значения
параметров,  которые  будут  использоваться  для  выполнения  запросов получения
данных - запросов второй категории.

  Конфигурационные  запросы  -   запросы   третьей  категории  -  обрабатываются
непосредственно         в         конструкторе         класса        JSONReader.
Собственно    выполнение    прочих    запросов    осуществляется    при   вызове
дополнительных   специальных  методов  класса  JSONReader,  в  его  конструкторе
они   только   запоминаются  в  особом  внутреннем  представлении.  Кроме  того,
существуют            также            служебные            операции           -
   вспомогательные   операции,   обеспечивающие   обслуживание   справочника  и
некоторые действия с его внутренним состоянием.

  Исполнение  запросов  первой  категорий -  запросов построения  базы  данных -
 выполняется  путём  вызова  публичного  метода  ProcessAddInfoRequests  класса
JSONReader.   Фрагмент   кода  ниже  демонстрирует  типичную  последовательность
рабочих операций для передачи справочнику таких запросов.

    // Создание объекта транспортного справочника.
    transport::TransportCatalogue trans_cat; 
    // Создание объекта-посредника и выполнение конфигурационных запросов.
    transport::reader::JSONReader jsr(ifile, trans_cat); 
    jsr.ProcessAddInfoRequests(); // выполнение запросов построения
    // Принудительное построение графа маршрутизации. Может продолжаться
    // очень долго.
    jsr.BuildBusRouter(); 
    jsr.ProcessSerialize(); // Сохранение в файл полного состояния справочника.

  Для   исполнения   запросов    второй   категории   служит   публичный   метод
ProcessGetInfoRequests  того  же  класса.  Возвращаемым  значением  этой функции
будет  JSON-документ  с  ответами  на  запросы.  Фрагмент  кода  ниже показывает
способ    работы   со   справочником   с   использованием   ранее   сохранённого
состояния.

     // Создание объекта транспортного справочника.
    transport::TransportCatalogue trans_cat;
    // Создание объекта-посредника и выполнение запроса конфигурации,
    // указывающего имя файла состояния.
    transport::reader::JSONReader jsr(ifile, trans_cat);
    // Восстановление состояния справочника, его базы данных и графа
    // маршрутизации.
    jsr.ProcessDeserialize();
    // Исполнение информационных запросов с получением ответа
    json::Document doc = jsr.ProcessGetInfoRequests();

  Запросы  второй  категории   всегда   будут   выполняться  на  основании  того
состояния  описания  транспортной  сети.  которое  сложилось  при обработке лишь
явно   исполненных   к   данному   моменту   строительных   и   конфигурационных
запросов   (для   которых   построен   объект  JSONReader  и  вызван  его  метод
ProcessAddInfoRequests).

-------------------------------------------

  Наконец,  предусмотрено три служебных,  вспомогательных  операции,  выполнение
каждого из которых инициируется вызовом отдельного метода.

  Метод  BuildBusRouter  служит   для   понуждения  справочника  к  немедленному
построению   особой   внутренней   структуры  -  маршрутизирующего  графа  -  на
основе  уже  полученных  к  данному  моменту  запросов построения. В норме такое
построение    будет    проводиться    автоматически   при   выполнении   первого
встреченного  запроса  прокладки  маршрута  (это  один  из видов запросов второй
категории),   если   к   этому  моменту  после  предыдущего  перестроения  графа
справочнику   передавались  какие-либо  запросы  первой  категории.  Введение  в
интерфейс    отдельного    метода    для    принудительного    построения    или
перестроения   маршрутизирующего   графа   связано   с  наличием  в  нём  особой
функции   сохранения   и   восстановления  его  текущего  состояния  -  запросов
сериализации/десериализации   объекта   справочника.   По   такому   запросу   в
указанный  файл  будет  сохранено  текущее  состояние  справочника в специальном
формате данных, обеспечиваемом библиотекой Protobuf.

  Потом по другому  запросу  сохранённое  состояние  может  быть  в любой момент
восстановлено   из   этого   файла,   после   чего   работа   справочника  будет
продолжена  с  момента  сохранения  данных.  Операция  сериализации  выполняется
при  вызове  метода  ProcessSerialize  класса  JSONReader,  а  десериализация  -
при вызове метода ProcessDeserialize.

  Так  как построение  маршрутизирующего  графа  -  весьма  ресурсоёмкая  задача
и   может   занимать  значительное  время,  то  наличие  в  структуре интерфейса
метода   BuildBusRouter   обеспечивает   дополнительную   гибкость  и  позволяет
выбрать  временную  точку,  когда  эта  операция  будет  сделана - до исполнения
сериализации  (в  этом  случае  состояние  будет  сохранено  уже  с  построенным
графом)   или  после  таковой  (в  этом  случае  состояние  не  будет  содержать
этого графа).

Условное иллюстративное объявление класса JSONReader:

    class JSONReader
    {
    public:
        JSONReader(std::istream& input, TransportCatalogue& trans_cat);
        // Метод для исполнения запросов на ввод информации в базу данных.
        void ProcessAddInfoRequests();
        // Метод для исполнения запросов для получения информации из базы
        // данных.
        Document ProcessGetInfoRequests();
        // Метод для принудительной постройки или перестройки маршрутизирующего
        // графа на основе текущего состояния базы данных транспортного 
        // справочника.
        void BuildBusRouter();
        // Исполнители запросов на сериализацию/десериализацию.
        void ProcessSerialize();
        void ProcessDeserialize();
    ...............................................................
    ...............................................................
    };


Структура и формат JSON-запросов.
---------------------------------

  На   рисунке   ниже    приведён   типичный   JSON-документ,   содержащий   все
возможные    построительные    и    конфигурационные   запросы,   поддерживаемые
текущей версией справочника:

    {
        "serialization_settings": {
          "file": "transport_catalogue.db"
        },
        "base_requests": [
          {
              "is_roundtrip": true,
              "name": "289",
              "stops": [
                  "Zagorye",
                  "Lipetskaya ulitsa 46",
                  "Lipetskaya ulitsa 40",
                  "Lipetskaya ulitsa 40",
                  "Lipetskaya ulitsa 46",
                  "Moskvorechye",
                  "Zagorye"
              ],
              "type": "Bus"
          },
          {
              "latitude": 55.579909,
              "longitude": 37.68372,
              "name": "Zagorye",
              "road_distances": {
                  "Lipetskaya ulitsa 46": 230
              },
              "type": "Stop"
          },
          {
              "latitude": 55.581441,
              "longitude": 37.682205,
              "name": "Lipetskaya ulitsa 46",
              "road_distances": {
                  "Lipetskaya ulitsa 40": 390,
                  "Moskvorechye": 12400
              },
              "type": "Stop"
          },
          {
              "latitude": 55.584496,
              "longitude": 37.679133,
              "name": "Lipetskaya ulitsa 40",
              "road_distances": {
                  "Lipetskaya ulitsa 40": 1090,
                  "Lipetskaya ulitsa 46": 380
              },
              "type": "Stop"
          },
          {
              "latitude": 55.638433,
              "longitude": 37.638433,
              "name": "Moskvorechye",
              "road_distances": {
                  "Zagorye": 10000
              },
              "type": "Stop"
          }
        ],
        "render_settings": {
          "bus_label_font_size": 20,
          "bus_label_offset": [
              7,
              15
          ],
          "color_palette": [
              "green",
              [
                  255,
                  160,
                  0
              ],
              "red"
          ],
          "height": 200,
          "line_width": 14,
          "padding": 30,
          "stop_label_font_size": 20,
          "stop_label_offset": [
              7,
              -3
          ],
          "stop_radius": 5,
          "underlayer_color": [
              255,
              255,
              255,
              0.85
          ],
          "underlayer_width": 3,
          "width": 200
        },
        "routing_settings": {
          "bus_velocity": 30,
          "bus_wait_time": 2
        }
    } 

  Серия  запросов  объединена   в   один   JSON-документ.   На  верхней  ступени
JSON-иерархии    такой    документ   должен   представлять   собой   словарь   -
ассоциативный   массив,   представляющий  собой  пары  ключ-значение.  В  данном
случае           ключ          -          имя          класса          запросов.
Существуют следующие такие классы:

1. serialization_settings - настройки для выполнения операций
сериализации/десериализации
2. render_settings - уставки, используемые для построения графической
карты транспортной системы.
3. routing_settings - уставки и настройки. применяемые при прокладке маршрутов.
4. base_requests - запросы построения: запросы для передачи информации
об устройстве транспортной маршрутной системы.
5. stat_requests - информационные запросы: запросы для получения
информации от справочника.

Первые   три   класса   запросов   (serialization_settings,   render_settings  и
routing_settings)  -  конфигурационные,  а  последний  класс  (base_requests)  -
построительный. Их дальнейшая, нижележащая структура отличается.

  Значением  словарной  пары   в   случае   запроса  конфигурации  должен  также
являться   словарь,   вложенный   словарь   следующего,   более  низкого  уровня
JSON-иерархии.   Пары   ключ-значение  такого  словаря  имеют  следующий  смысл:
ключ   -  имя  параметра,  установка  которого  выполняется,  значение  из  пары
будет   присвоено   этому   параметру.   Значения  могут  быть  как  одиночными,
скалярными,   так   и   массивами,   векторами.  Список,  возможные  значения  и
функции   всех  допустимых  параметров  для  перечисленных  выше  поддерживаемых
классов   конфигурационных   запросов   перечислено   в   приложении  к  данному
документу.

  Структура  построительных  запросов   следующая:   значением  в  паре,  ключом
которой   является   строка   "base_requests",  должен  быть  массив,  отдельные
элементы  которого  должны  являться  словарями.  Каждый  из  подобных  словарей
соответствует  индивидуальному  запросу  построения  и  описывает  особый объект
маршрутной    транспортной   сети.   Таких   объектов   поддерживается   два   -
остановочные   пункты   и.   собственно,   транспортные  (автобусные)  маршруты,
следующие между этими остановочным пунктами (остановками).

  Различение   описываемых   объектов    выполняется    по    виду   обязательно
содержащейся   в   таком  словаре  словарной  пары,  ключ  которой  должен  быть
равен  строке  "type".  Различных  значений  же  в  такой паре допускается два -
строки  "Stop"  или  "Bus".  Первый  запрос  будет описывать остановку, а второй -
автобусный маршрут.

  Описание  автобуса  выглядит   следующим   образом   :  оно  состоит  из  трёх
дополнительных    словарных    пар    (кроме    пары    с   ключом   "type")   -
пар  с  ключами  "name",  "is_roundtrip"  и "stops". Значение в паре "name" -
имя   автобуса,   произвольная   текстовая  строка.  Имя  для  каждого  автобуса
должно  быть  уникальным,  каждое  имя  может  обозначать только один конкретный
автобус   во   всей   транспортной   системе.  Значение  в  паре  "is_roundtrip"
логическое   и   указывает,   является  ли  данный  автобус  кольцевым  (в  этом
случае  значение  должно  быть  равным  true)  или  нет  (тогда  значение в паре
должно   быть   false).   Отличие  порядка  следования  автобуса  по  кольцевому
маршруту   от   движения   по  некольцевому  разъясняется  далее  в  приложении.
Наконец,   значение  пары  с  ключом  "stops"  -  массив  с  именами  остановок,
через которые следует автобус.

    {
      "is_roundtrip": true,
      "name": "289",
      "stops": [
          "Zagorye",
          "Lipetskaya ulitsa 46",
          "Lipetskaya ulitsa 40",
          "Lipetskaya ulitsa 40",
          "Lipetskaya ulitsa 46",
          "Moskvorechye",
          "Zagorye"
      ],
      "type": "Bus"
    }

  Такой запрос добавит  к  базе  автобус  под  именем  "289", кольцевой, маршрут
которого    проходит   через   остановки   "Загорье",   "Липецкая   улица   46",
"Липецкая  улица  40",  "Липецкая  улица  40"  (повторно,  это может быть другой
остановочный    павильон    той    же    остановки),    "Липецкая   улица   46",
"Москворечье",     "Загорье".    Конечные    остановки    кольцевого    маршрута
совпадают.

  Описание    остановки   формируется    так:    оно    состоит    из    четырёх
дополнительных    словарных    пар    со    следующими    ключами    -   "name".
"latitude",   "longitude"  и  "road_distances".  "name"  -  название  остановки,
произвольная    текстовая    строка,    служащая    уникальным   идентификатором
остановки.  Оно  более  не  должно  повторяться  во  всей  транспортной системе.
"latitude"   и   "longitude"   -   дробные   числа,  указывающие  географические
широту и долготу точки расположения остановки.

  Наконец,  значением  словарной   пары   с   ключом  "road_distances",  в  свою
очередь,   должен   быть  очередной  вложенный  словарь.  Словарные  пары  этого
словаря   определяют   измеренное  расстояние  по  дорогам,  соединяющим  данную
остановку   с   всеми   её   смежниками  (ближайшими  соседями)  -  остановками,
которые  находятся  от  неё  в  одном  автобусном перегоне (в одном остановочном
интервале  по  какому-либо  автобусному  маршруту).  Ключ  каждой  такой  пары -
имя  смежной  остановки,  значение  -  число  с  плавающей точкой - расстояние в
метрах  между  ними  по  дорогам.  Если  какое-либо  расстояние  между  смежными
остановками   явно  не  задано,  то  при  прокладке  маршрута  расстояние  будет
рассчитываться по кратчайшей, исходя из их географических координат.

    {
        "latitude": 55.584496,
        "longitude": 37.679133,
        "name": "Lipetskaya ulitsa 40",
        "road_distances": {
            "Lipetskaya ulitsa 40": 1090,
            "Lipetskaya ulitsa 46": 380
        },
        "type": "Stop"
    }

  Такой запрос добавит  в  базу  остановку  под  именем  "Липецкая  улица  40" с
координатами   (широта   -   55.584496,  долгота  -  37.679133),  расстояние  по
дорогам  до  смежников  -  1090  метров  до  другого павильона той же остановки,
380 метров до остановки "Липецкая улица 46".

  Остальные запросы данной  серии  -  конфигурационные.  Каждый  такой  запрос -
словарь,  ключ  каждой  пары  которого  определяет   имя параметра, а значение -
значение  параметра.  Запрос  класса  "serialization_settings"  определяет  одно
единственное  допустимое  значение  -  имя  файла  сериализации, в которой будет
сначала сохраняться, а затем восстанавливаться состояние справочника.

    "file": "transport_catalogue.db"

Имя параметра - "file", значение - строка "transport_catalogue.db".

  Запрос  класса  "routing_settings"   определяет  настройки,  используемые  при
прокладке      маршрутов      поездок.     Поддерживаемых     параметра     два:
"bus_velocity"    -    средняя    скорость    движения    автобуса    в    км/ч,
"bus_wait_time"   -  время,  затрачиваемой  пассажиром  на  посадку/пересадку  в
минутах.

    "routing_settings": {
      "bus_velocity": 30,
      "bus_wait_time": 2
    }

  В таком запросе средняя скорость автобуса - 30 км/ч, среднее время ожидания на
остановке - 2 минуты.
  Самый  богатый  по   поддерживаемому  разнообразию  настроек  конфигурационный
запрос   -   запрос   класса   "render_settings".   Он   определяет   параметры,
применяемые   при   построении   графического   изображения  транспортной  сети.
Такая  картина  представляет  собой  векторный  SVG-файл  и состоит из множества
отдельных    графических    элементов,    внешний    вид    каждого    поддаётся
определённой модификации.

Список поддерживаемых параметров:

+  width  и  height  —  ключи,  которые  задают  ширину  и  высоту  в  пикселях.
Вещественное число в диапазоне от 0 до 100000.
+  padding  —  отступ  краёв  карты  от границ SVG-документа. Вещественное число
не меньше 0 и меньше min(width, height)/2.
+  line_width   —   толщина   линий,   которыми  рисуются  автобусные  маршруты.
Вещественное число в диапазоне от 0 до 100000.
+  stop_radius   —   радиус   окружностей,   которыми  обозначаются   остановки.
Вещественное число в диапазоне от 0 до 100000.
+  bus_label_font_size    —   размер   текста,   которым    написаны    названия
автобусных маршрутов. Целое число в диапазоне от 0 до 100000.
+  bus_label_offset  —  смещение  надписи   с  названием  маршрута  относительно
координат   конечной   остановки   на  карте.  Массив  из  двух  элементов  типа
double.   Задаёт   значения  свойств  dx  и  dy  SVG-элемента  <text>.  Элементы
массива — числа в диапазоне от –100000 до 100000.
+  stop_label_font_size   —   размер   текста,  которым  отображаются   названия
остановок. Целое число в диапазоне от 0 до 100000.
+  stop_label_offset   —   смещение    названия    остановки   относительно   её
координат    на    карте.    Массив    из    двух    элементов    типа   double.
Задаёт  значения  свойств  dx  и  dy  SVG-элемента  <text>. Числа в диапазоне от
–100000 до 100000.
+  underlayer_color  —  цвет  подложки  под  названиями  остановок  и маршрутов.
Формат   хранения   цвета,   применяемый   во   всех   цветоопределяющих   полях
запросов, будет описан ниже.
+  underlayer_width   —   толщина   подложки   под    названиями   остановок   и
маршрутов.    Задаёт    значение    атрибута   stroke-width   элемента   <text>.
Вещественное число в диапазоне от 0 до 100000.
+ color_palette — цветовая палитра. Непустой массив.

Цвет можно указать одниз их трёх способов:

- в виде строки, например, "red" или "black";
- в  массиве   из  трёх  целых чисел диапазона [0, 255]. Они определяют r, g и b
компоненты  цвета  в  формате  svg::Rgb.  Цвет  [255,  16, 12] нужно вывести как
rgb(255, 16, 12);
- в  массиве  из   четырёх  элементов:  три  целых  числа  в  диапазоне [0, 255]
и  одно  вещественное  число в  диапазоне  [0.0,  1.0]. Они  задают составляющие
red,  green,  blue  и  opacity   цвета  формата  svg::Rgba.  Цвет, заданный  как
[255,  200,  23,  0.85],  должен  быть выведен как rgba(255, 200, 23, 0.85).

Каждый цвет должен быть задан в одном из этих трёх форматов.

  Теперь рассмотрим формат  и  структуру  запросов  на  получение  информации  -
запросов   второй   категории.   Ниже  приведён  JSON-документ,  содержащий  все
возможные такие запросы.

    {
      "serialization_settings": {
          "file": "transport_catalogue.db"
      },
      "stat_requests": [
          {
              "id": 80146768,
              "type": "Bus",
              "name": "13"
          },
          {
              "id": 1571442892,
              "type": "Stop",
              "name": "Морской вокзал"
          },
          {
              "id": 1490699931,
              "type": "Route",
              "from": "Пансионат Нева",
              "to": "Улица Лысая Гора"
          },
          {
              "id": 684758285,
              "type": "Map"
          }
      ]
    }

  Структура  информационных  запросов   напоминает   описанные   ранее   правила
составления   построительных   запросов:  все  запросы  объединяются  в  массив,
который  должен  являться  значением  в  словарной  паре словаря верхнего уровня
JSON-документа,   ключом   же   в  этой  паре  будет  строка  "stat_requests"  -
имя   класса   для   информационных   запросов.   Таких   запросов   (второй
категории)  существует  четыре:  получение  информации  об  автобусе,  получение
информации    об    остановке,   запрос   на   прокладку   маршрута,   получение
графического изображения транспортной сети.

  Отдельные  запросы,  как  и  ранее,  также  являются  словарями.  Тип  запроса
определяется   словарной   парой   с   ключом   "type",   значение   которой   и
определяет   тип  запроса.  Значение  "Bus"  -  запрос  информации  о  маршруте,
значение  "Stop"  -  информация  об  остановке,  значение  "Route"  - требование
прокладки     наибыстрейшего    маршрута,    соединяющего    две    какие-нибудь
остановки, и, наконец, значение "Map" - построение изображения сети.

  Запросы   "Bus"  и  "Stop"  содержат  ассоциативный элемент  с ключом  "name",
значение   которого   -   имя   интересующего   объекта,  информация  о  котором
затребована.  Маршрутный  запрос  "Route"  должен  содержать  две словарных пары
с   ключами   "from"   и  "to".  Их  значения  -  названия  остановок.  служащих
начальным   и   конечным   пунктами   прокладываемого  маршрута  соответственно.
Запрос "Map" дополнительных параметров не имеет.

  Кроме  того, каждый  запрос  должен  содержать  ассоциативную  пару  с  ключом
"id"   и   значением   в   виде  целого  положительного  числа,  уникальные  для
каждого  из  запросов,  входящих  в  одну  серию.  Это  пара  позволит различить
ответы,    возвращенные    справочником,   и   однозначно   сопоставить   их   с
конкретными  запросами  серии,  так  как  порядок  ответов  может не совпадать с
порядком запросов.

  В  вышеприведённом  JSON-документе   наличествуют  четыре  запроса:  запрос  с
id  =  80146768  вернёт  информацию  об  автобусе  с  именем "13", запрос с id =
1571442892   возвратит   информацию   об   остановке   под   названием  "Морской
вокзал",  запрос  с  id  =  1490699931  проложит  самый  быстрый маршрут поездки
от  остановки  "Пансионат  Нева"  до  остановки  "Улица Лысая Гора", и, наконец,
последний   запрос   с   id   =   684758285   сгенерирует  условное  графическое
изображение  транспортной  сети  в  виде  векторного  SVG-файла.  Выглядеть  всё
это будет так:

    [
        {
            "curvature": 1.26723,
            "request_id": 80146768,
            "route_length": 5540,
            "stop_count": 7,
            "unique_stop_count": 4
        },
        {
            "buses": [
                "23",
                "36"
            ],
            "request_id": 1571442892
        },
        {
            "items": [
                {
                    "stop_name": "Пансионат Нева",
                    "time": 2,
                    "type": "Wait"
                },
                {
                    "bus": "23",
                    "span_count": 8,
                    "time": 11.82,
                    "type": "Bus"
                },
                {
                    "stop_name": "Пансионат Светлана",
                    "time": 2,
                    "type": "Wait"
                },
                {
                    "bus": "44к",
                    "span_count": 1,
                    "time": 2.14,
                    "type": "Bus"
                }
            ],
            "request_id": 1490699931,
            "total_time": 17.96
        },
        {
            "map": "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"
                    version=\"1.1\">\n<polyline points=\"399.983,528.273 345.993,553.659 317.894,581.093 
                    276.547,657.748 317.894,581.093 345.993,553.659 399.983,528.273\" fill=\"none\"
                    stroke=\"red\" stroke-width=\"10\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>
                    .......................................................................................
                    </svg>"
            "request_id": 684758285
        }
    ]

  Это типичный ответ  справочника  на  все  вышеприведённые  запросы.  Он  также
имеет   вид  JSON-документа  и  на  верхнем  уровне  представляет  собой  массив
словарей,   каждый   из   которых   является   ответом   на   отдельный  запрос.
Рассмотрим   его   чуть   внимательнее.   Первый  словарь  содержит  сведения  о
маршруте   автобуса   с   именем   "13"   (обратите   внимание   на   совпадение
request_id   =   80146768  с  id  соответствующего  запроса).  Среди  них  общая
длина   маршрута   ("route_length":  5540),  количество  остановок  на  маршруте
("stop_count":   7),   количество   различных  среди  них  ("unique_stop_count":
4),   и,   наконец,   извилистость   маршрута  -  отношение  длины  маршрута  по
дорогам  к  гипотетической  длине  пути  по  кратчайшим линиям между остановками
("curvature": 1.26723).

  Второй  ответ -  ответ на  запрос  информации  об  остановке  "Морской вокзал"
("request_id":    1571442892).    Он   содержит   только   массив   со   списком
автобусов, проходящих через остановку (массив "buses").

  Третий   ответ  ("request_id":   1490699931)   -   проложенный   наибыстрейший
маршрут,  по  которому  можно  проехать  на  автобусах  от  остановки "Пансионат
Нева"   до   остановки   "Улица  Лысая  Гора"  за  минимально  возможное  время.
Маршрут  изложен  как  список  элементов  маршрута,  которые хранятся как массив
словарей,   являющийся   значением  словарной  пары  с  ключом  "items".  Каждый
элемент  описывается  своим  словарём.  Эти  элементы  возможны  двух  различных
типов,  которые  различаются  значением  словарной  пары  с  ключом "type". Если
это  значение  равно  "Bus",  элемент  -  непрерывная  поездка на автобусе через
"span_count"  перегонов  на  автобусе  с  именем  "bus",  которая  займёт "time"
минут.  Если  же  значение  будет  равно  "wait", элемент маршрута - ожидание на
остановке с именем "stop_name", которое продлится "time" минут.

  Также  описание  маршрута   сопровождается  общей  продолжительностью  поездки
по предложенному маршруту ("total_time": 17.96).

  Наконец,  последний,  четвёртый   ответ   -   это  ответ  на  запрос  "Map"  о
построении  изображения  маршрутной  сети.  Ответом  является  словарная  пара с
ключом    "map",    значением    которой    является   строка,   непосредственно
включающая            в           себя           содержимое           SVG-файла.
Если  сохранить  эту  строку  в  виде  файла,  то  результатом будет стандартный
графический  SVG-файл,  который  может  прменяться  точно  так  же,  как и любой
другой  файл  этого  формата.  В  связи  с  очень  большим  размером, здесь этот
ответ приведён условно.

  Дополнительно  опишем  ещё   особенность   кольцевых   автобусных   маршрутов.
Каждый  маршрут,  как  уже  указывалось  выше,  описывается  перечнем остановок,
через  которые  он  пролегает.У  обычного,  некольцевого  автобуса (для которого
"is_roundtrip":  false)  маршрут  состоит  из  двух  независимых ветвей "туда" и
"обратно",   он   следует   между  своими  конечными  остановками  независимо  в
обоих   направлених.   У   кольцевого   же   автобуса   ("is_roundtrip":   true)
конечные   остановки,  обычно,  совпадают  (хотя  это  не  обязательно),  и  его
маршрут   состоит   только   из  одной  ветви,  от  первой  остановки  списка  к
последней.

Обработка исключений при работе с программой.
---------------------------------------------

  Программа   не  предназначена   на   данный   момент   для   использования   в
промышленных   условиях,   поэтому   не   обладает   достаточной  надёжностью  и
сколь-нибудь     исчерпывающей     внутренней    обработкой    ошибок    входной
информации.   Поэтому   наличие  ошибок  в  структуре  или  содержании  входного
JSON-документа,   передающего   запросы   в   программу,   может   приводить   к
возникновению   различных   исключений.   Отклонение   структуры   запросов   от
требуемой может вызвать исключение класса ParsingError.

  Ошибки  в  содержании   такого   JSON-документа,   отсутствие   или   неверное
значение  различных  параметров  конфигурации,  может  приводить  к выбрасыванию
также    широкого   перечня   типовых   исключений,   генерируемых   библиотекой
периода исполнения C++ и/или системным окружением.

Планы на будущее.
-----------------

  Перспективы  доработки  этой  программы  воистину  необозримы.  Прежде  всего,
обратим    внимание   на    недостаточную   гибкость   при   задании   временных
характеристик   движения  автобусов  и  пассажиров.  В  данный  момент  для  них
принята   простейшая   модель,   в  которой  все  они  описываются  всего  двумя
величинами:    скоростью    движения   автобусов   по   маршрутам   и   временем
пребывания    пассажиров    на    остановках,   в   которое   входят   ожидание,
посадка/высадка,    перемещение    пассажиров    между   разными   остановочными
площадками,   и.   т.   д.  Эти  величины  вдобавок  считаются  константами,  не
зависящими   вообще   ни   от   каких  факторов  -  ни  от  конкретной  дорожной
ситуации  на  дорогах,  по  которым  проложен  маршрут,  ни  от  расположения  и
конфигурации остановочных пунктов.

  Разумеется,  чтобы  такая  идеализация  приобрела  хоть  какое-то  сходство  с
реальностью,   принятую  модель  следует  доработать,  учтя  различную  величину
как   скорости   движения  автобусов,  так  и  затраты  времени  пассажирами  на
посадочно/пересадочные   операции.  Причём  эти  параметры  должны  зависеть  не
только   от  относительно  устойчивого  географического  расположения  маршрутов
и   остановок,  но  могут  стремительно  меняться  во  времени,  как  в  течение
суток,   так  и  в  течение  более  продолжительных  календарных  циклов.  Кроме
того,  такие  изменения  могут  носить  не  только  монотонный, но и мгновенный,
экстраординарный   характер,   например,   в   случае   какого-либо   стихийного
бедствия.

  Принятый  в  программе   алгоритм   решения   задач   на  графах  имеет  очень
высокую   вычислительную   трудность   при  постройке  графа  маршрутизации,  но
зато  позволяет  очень  быстро  прокладывать  любые  маршруты,  если  этот  граф
уже   существует.   Такой   подход   является   весьма  эффективным,  если  граф
перестраивается   очень  редко.  Но  так  как  подобную  перестройку  приходится
делать   при  каждом  изменении  временных  характеристик  агентов  транспортной
сети,   то  для  такой  высокодинамичной  задачи  используемый  алгоритм  теряет
свою эффективность и, возможно, должен быть заменён на другой.

Компиляция и сборка программы.
------------------------------

  Компиляция   программы   может    быть    совершена   с   применением   любого
компилятора    C++17.    К    проекту    приложен   сборочный   cmake-скрипт   и
подготовленное   решение   для   Visual   Studio.   Единственной   нестандартной
внешней   зависимостью   является   библиотека   Google   Protobuf.  Причём  для
полной   сборки   необходим   не  только  её  рантайм-модуль,  но  и  компилятор
proto-схем,   поэтому  перед  компиляцией  проекта  следует  надлежащим  образом
установить её в целевую систему.

  В  репозитории  хранятся   также   заранее   прекомпилированные  схемы  (схемы
*.proto,   транслированные   в  файлы  *.cc  и  *.pb.h),  что  делает  возможным
сборку  без  наличия  транслятора  схем.  Но  рантайм-модуль  Protobuf всё равно
необходим.   В   случае   применения  готового  решения  (TransportCatalogu.sln)
после  открытия  его  в  Visula  Studio  следует  провести  некоторые настройки,
указав  положение  заголовков  Protobuf  в  составе  каталогов  для подключаемых
файлов,    а   также   точное   размещение   его   двоичной   рантайм-библиотеки
(libprotobuf.lib или libprotobufd.lib).
